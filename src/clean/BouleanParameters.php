<?php


namespace victor\refactoring;

$boule = new BouleanParameters();
$boule->bigUglyMethod(1, 2);
$boule->bigUglyMethod(1, 2);
$boule->bigUglyMethod(1, 2);
$boule->bigUglyMethod(1, 2);
$boule->bigUglyMethod(1, 2);

// TODO From my use-case, I call it too, to do more within:
$boule->bigUglyMethod323(1, 2);

class BouleanParameters
{


    function bigUglyMethod(int $aId, int $b)
    {
        $this->beforeLogic($aId, $b);
        $this->afterLogic($aId, $b);
    }

    /**
     * @param int $a
     * @param int $b
     */
    private function beforeLogic(int $a, int $b): void
    {

        echo "Complex Logic with $a\n";
        echo "Complex Logic $b\n";
        echo "Complex Logic $a\n";
    }


    // ============== "BOSS" LEVEL: A lot harder to break down =================

    /**
     * @param int $a
     * @param int $b
     */
    private function afterLogic(int $a, int $b): void
    {
        echo "More Complex Logic $a\n";
        echo "More Complex Logic $a\n";
        echo "More Complex Logic $b\n";
    }

    function bigUglyMethod323(int $a, int $b)
    {

        $varx = "wow";
        $$varx = 1;

        $this->beforeLogic($a, $b);
        echo "#sieu da pe usecaseul meu de cr323";
        $this->afterLogic($a, $b);
    }

    function bossLevel(bool $stuff, bool $fluff, array $tasks)
    {
        $ii = 0;
        $j = 1;
        echo "Logic1\n";
        if ($stuff) {
            echo "Logic2\n";
            if ($fluff) {
                echo "Logic3\n";
                foreach ($tasks as $task) {
                    $ii++;
                    echo "Logic4 " . $task . "\n";
                    // TODO HERE, when call this method, I want MY own custom code to run here
                    echo "Logic5 " . $ii . "\n";
                }
                echo "Logic6 " . ($j++) . "\n";
            }
        }
        echo "Logic7\n";
    }
}

class Georgel {

}


$arrayObject = new GeorgelArray();
foreach ($arrayObject as $g) {

}

class GeorgelArray extends \ArrayObject {
    public function append(Georgel $value)
    {
        parent::append($value); // TODO: Change the autogenerated stub
    }
    public function getIterator(): GeorgelIterator
    {
        parent::getIterator(); // TODO: Change the autogenerated stub
    }
}
class GeorgelIterator extends \ArrayIterator {
    public function current(): George
    {
        parent::current(); // TODO: Change the autogenerated stub
    }
}
new \Exception("a",19851)


class ReglissException extends \Exception {
}
class AltCazParticularPeCareFacCatchSelectiv extends ReglissException {
}
// dar nu faci niciodata in cod "catch(MyException"" -- sterge exceptia si foloseste doar codul pentru a 'traduce' eroare pentru usr

$errMess = [
    AltCazParticularPeCareFacCatchSelectiv::class => "Mesaj ",
    // 19851 => "Mesaj ",
]

